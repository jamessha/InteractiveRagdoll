/*    TextureExamples/texquadric.cpp      */
/*
 * This uses the same textures as tex2.cpp, only this time they are
 * applied to quadric surfaces -- cones.  The cone on the top
 * uses quadric textures; for the one on the bottom we generate
 * texture coordintes ourselves.
 */

#include <GL/glut.h>
#include <GL/glui.h>

#define SPEED 0.1

GLfloat X = 30.0;
GLfloat Y = 0.0;
GLfloat Z = 0.0;
int main_window;
float theta = 0.0;
float delta_theta = SPEED;

GLfloat lightPos[4] = {30.0, 10.0, 10.0, 1.0};

GLfloat textureMap[64][64][3];
GLuint tex[2];


void assignColor(GLfloat col[3], GLfloat r, GLfloat g, GLfloat b) {
	col[0] = r;
	col[1] = g;
	col[2] = b;
}

int isEven(int x) {
	if (x%2 == 0)
		return 1;
	else
		return 0;
}

void makeTextureMap() {
	for (int i = 0; i < 64; i++ )
		for (int j = 0; j< 64; j++ ) {
			if (isEven( i/8 + j/8)) 
				assignColor(textureMap[i][j], 1.0, 1.0, 1.0);
			else
				assignColor(textureMap[i][j], 1.0, 0.0, 0.0);
		}
}

void makeTextures() {
	GLfloat planes[] = {0.0, 0.0, 0.3, 0.0};
	GLfloat planet[] = {0.0, 0.3, 0.0, 0.0};

	glGenTextures(2, tex);

	glBindTexture(GL_TEXTURE_2D, tex[0]);
	glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
	glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
	glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
	glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
	glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE);
	glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, 64, 64, 0, GL_RGB, GL_FLOAT, textureMap);
  
	/************************************ */
	glBindTexture(GL_TEXTURE_2D, tex[1]);
	glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
	glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT); 
	glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
	glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
  
	glTexGeni(GL_S, GL_TEXTURE_GEN_MODE, GL_OBJECT_LINEAR);
	glTexGenfv(GL_S, GL_OBJECT_PLANE, planes);
	glTexGeni(GL_T, GL_TEXTURE_GEN_MODE, GL_OBJECT_LINEAR);
	glTexGenfv(GL_T, GL_OBJECT_PLANE, planet);
	glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, 64, 64, 0, GL_RGB, GL_FLOAT, textureMap);
}


void reshape(int w, int h) {
	int tx, ty, tw, th;

	GLUI_Master.get_viewport_area(&tx, &ty, &tw, &th);
	glViewport(tx, ty, tw, th);

	float aspect = th*1.0/tw;
	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();
	gluPerspective(60.0, aspect, 0.5, 200.0);
	glMatrixMode(GL_MODELVIEW);
	glutSetWindow(main_window);
	glutPostWindowRedisplay(main_window);  
}

void drawCylinder1( ) {
	GLUquadricObj *cylinder = gluNewQuadric();
  
	glBindTexture(GL_TEXTURE_2D, tex[0]);
	gluQuadricTexture(cylinder, GL_TRUE); 
	gluQuadricDrawStyle(cylinder, GLU_FILL); 
	glPolygonMode(GL_FRONT, GL_FILL); 
	gluQuadricNormals(cylinder, GLU_SMOOTH);
	gluCylinder(cylinder, 3.0, 0.0, 6.0, 20, 100);
}

void drawCylinder2( ) {
	glEnable(GL_TEXTURE_GEN_S);
	glEnable(GL_TEXTURE_GEN_T);
	glBindTexture(GL_TEXTURE_2D, tex[1]);

	GLUquadricObj *cylinder = gluNewQuadric();
  
	gluQuadricDrawStyle(cylinder, GLU_FILL); 
	glPolygonMode(GL_FRONT, GL_FILL); 
	gluQuadricNormals(cylinder, GLU_SMOOTH);
	gluCylinder(cylinder, 3.0, 0.0, 6.0, 20, 100);
	glDisable(GL_TEXTURE_GEN_S);
	glDisable(GL_TEXTURE_GEN_T);
}

void display() {
	glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT);
	glMatrixMode(GL_MODELVIEW);

	glPushMatrix();
	glTranslatef(0.0, 0.0, 0.0);
	glRotatef(theta, 0.0, 0.0, 1.0);
	drawCylinder1();
	glPopMatrix();

	glPushMatrix();
	glTranslatef(0.0, 0.0, -10.0);
	glRotatef(theta, 0.0, 0.0, 1.0);
	drawCylinder2();
	glPopMatrix();

	glutSwapBuffers(); 
}

void light_callback(int ID) {
	glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT);
	glLightfv(GL_LIGHT0, GL_POSITION, lightPos);
	glutPostWindowRedisplay(main_window);
}

void pause_callback(int ID) {
	if (delta_theta < 0.001)
		delta_theta = SPEED;
	else
		delta_theta = 0.0;
}

void spin() {
	theta += delta_theta;
	glutPostWindowRedisplay(main_window);
}

void init() {
	GLfloat light_ambient[] = {0.0, 0.0, 0.0, 1.0};
	GLfloat light_diffuse[] = {1.0, 1.0, 1.0, 1.0};
	GLfloat light_specular[] = {1.0, 1.0, 1.0, 1.0};

	glClearColor(1.0, 1.0, 1.0, 1.0);
	glColor3f(0.0, 0.0, 0.0);
	glMatrixMode(GL_MODELVIEW);
	glLoadIdentity();
	gluLookAt(X, Y, Z, 0.0, 0.0, 0.0, 0.0,  0.0, 1.0);
 
	glEnable(GL_DEPTH_TEST);
	glEnable(GL_LIGHTING);
	glEnable(GL_LIGHT0);
	glEnable(GL_TEXTURE_2D);
	makeTextureMap();
	makeTextures();
	glLightfv(GL_LIGHT0, GL_AMBIENT, light_ambient);
	glLightfv(GL_LIGHT0, GL_DIFFUSE, light_diffuse);
	glLightfv(GL_LIGHT0, GL_SPECULAR, light_specular);
	glLightfv(GL_LIGHT0, GL_POSITION, lightPos);
}

int main(int argc, char **argv) {
	glutInit(&argc, argv);
	glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGB | GLUT_DEPTH);
	glutInitWindowSize(500, 500);
	glutInitWindowPosition(0, 0);

	main_window = glutCreateWindow( "textures" );
	glEnable(GL_DEPTH_TEST);

	init();
	glutReshapeFunc(reshape); 
	glutDisplayFunc(display);

	GLUI *control_panel = GLUI_Master.create_glui( "Controls", 0, 50, 530);
	new GLUI_Button(control_panel, "Quit", 0, (GLUI_Update_CB)exit);
	new GLUI_Button(control_panel, "Pause/Restart", 0, pause_callback);
    new GLUI_Separator(control_panel);

    new GLUI_Column(control_panel, true);

	GLUI_Rollout *light_position_rollout = new GLUI_Rollout(control_panel,
															"Light Position", false );
	GLUI_Spinner *x_light=new GLUI_Spinner(light_position_rollout, "X", GLUI_SPINNER_FLOAT, &(lightPos[0]), 1, light_callback);

	x_light->set_float_limits(-50.0, 50.0, GLUI_LIMIT_CLAMP);
	GLUI_Spinner *y_light=new GLUI_Spinner(light_position_rollout, "Y", GLUI_SPINNER_FLOAT, &(lightPos[1]), 2, light_callback);
	y_light->set_float_limits(-50.0, 50.0, GLUI_LIMIT_CLAMP);
	GLUI_Spinner *z_light=new GLUI_Spinner(light_position_rollout, "Z", GLUI_SPINNER_FLOAT, &(lightPos[2]), 3, light_callback);
	z_light->set_float_limits(-50.0, 50.0, GLUI_LIMIT_CLAMP);

	control_panel->set_main_gfx_window(main_window);

	GLUI_Master.set_glutIdleFunc(spin);
	glutSetWindow(main_window);

	glutMainLoop();

}



















